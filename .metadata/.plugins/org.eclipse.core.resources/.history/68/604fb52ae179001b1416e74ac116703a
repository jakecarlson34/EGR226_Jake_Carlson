/**************************************************************************************
* Author: Jake Carlson
* Course: EGR 226 - 902
* Date: 02/28/2021
* Project: lab06part1
* File: main.c
* Description: This program takes user input from a keypad and prints it to the screen.
*
*
*
**************************************************************************************/


#include "msp.h"
#include <stdio.h>
#include <stdlib.h>


/**
 * main.c
 */

uint8_t Keypad_Read(void);
void SysTick_Delay(uint16_t delayms);
void SysTick_Init();
uint8_t num, pressed;

void main(void)
{
	WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD;		// stop watchdog timer

	P4->SEL0 &= ~0xF;
	P4->SEL1 &= ~0xF;
	P4->DIR &= ~0xF;
	P4->REN |= 0xF;
	P4->OUT |= 0xF;

	P4->SEL0 &= ~0x70;
	P4->SEL1 &= ~0x70;
	P4->DIR &= ~0x70;

	SysTick_Init();

	printf("Please enter number");

	while(1){
	    pressed = Keypad_Read;

	    if(pressed){
	        SysTick_Delay(10);
	        if(num<10){
	            printf("\n[%d]\n", num);
	            fflush(stdout);
	        }
	        if(num == 10){
	             printf("\n[*]\n");
	             fflush(stdout);
	         }
	        if(num == 11){
	             printf("\n[0]\n");
	             fflush(stdout);
	         }
	        if(num == 12){
	              printf("\n[#]\n");
	             fflush(stdout);
	       }
	    }

	}




}
void SysTick_Init(){
    //systick init
        SysTick->CTRL = 0;
        SysTick->LOAD = 0x00FFFFFF;
        SysTick->VAL = 0;
        SysTick->CTRL = 0x00000005;



}
void SysTick_Delay(uint16_t delayms){


    SysTick->LOAD = ((3000 * delayms)-1);//using user input for delay
    SysTick->VAL = 0;
    while((SysTick->CTRL & 0x00010000)== 0);
    SysTick->CTRL = 0;//turn timer off
}

uint8_t Keypad_Read(void){
    uint8_t colu, row;

    for(colu = 0; colu< 3; colu++){
        P4->DIR = 0x00;
        P4->DIR |= BIT(4+colu);
        P4->OUT &= ~BIT(4+colu);

        SysTick_Delay(10);
        row = P4->IN & 0x0F;

        while(!(P4->IN & BIT0) | !(P4->IN & BIT1) | !(P4->IN & BIT2) | !(P4->IN & BIT3));

        if(row != 0x0F) break;
    }

    P4->DIR &= ~0x00;
    if(colu == 3){
        return 0;
    }

    if(row == 0x0E){
       num = colu +1;
    }
    if(row == 0x0D){
       num = 3 + colu +1;
    }
    if(row == 0x0B){
       num = 6 + colu +1;
    }
    if(row == 0x07){
       num = 9 + colu +1;
    }
    return 1;
}
